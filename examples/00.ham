import foo from "bar";

let foo = -45.2;
let bar = foo * 10 + (45 / 10 - -5);

foo = foo + 10;
bar -= 10;

const isGreater = foo > bar && !foo || bar;

const bar = 2 * -2 * (-3 + 1) + 1;  // 9
const foo = bar + 1 + 5 * 2 + -1;   // 19
const i = 1 / 3 % 2 + 10 + "liron"; // 10liron
const x = true && (false || true);  // true 
const y = 1 && "";                  // false

const foo: number = 34.2;
let bar: [][]number = [[1, 2], [2, 3], [3, 4]];

const foo = "liron1";
const bar = switch foo + 1 {
  1 + 2, 1 + 1 -> "1",
  4, 3 -> "2",
  _ -> "3",
}

const x = switch foo {
  case 1, 2 {
    1
  }
  case 3, 4 {
    2
  }
  default {
    3
  }
}

let x = if true { 
  let y = 10
  
  y + 1 
} else { 
  2 
}

let x = true ? 5 : 2

if foo == bar {
  x = 1;
} else if foo == 1 {
  y = 2;
} else {
  bar = 3;
}

for let i = 0; i < 10; i++ {
  if i == 1 {
    bar = i;
  }
}

const generator = fn(a: number) {
  return fn(b: number) { return a + b }
}

let add2 = generator(2)
let a = add2(10)

fn recursive(a) {
  if a == 0 {
    return 0
  }  

  return recursive(a - 1) + a
}

a = recursive(10)


const result = try {
  1 / 0
} catch {
  1 + 1
}

let myFunction: fn(a: number) -> any = nil

myFunction = fn(a: number) -> number {
  return 1
}

let z = myFunction(10)

fn x(arr) {
  (*arr)[0] = 10000
}

fn y(arr) {
  arr[0] = 111111
}

fn z(a) {
  a = 1000
}

let arr = [3]number{1, 2, 3}
let copy = arr
let f = copy[1]
copy[1] = 1
arr[2] = 100


x(&copy)
y(copy)
z(copy)


const arr = [3]number{1, 2, 3}

const copy = arr
const ref = &arr

(*ref)[1] = 10

copy[1] = 100
copy.set(1, 55)
arr[2] = 7

let nums2 = arr
nums2[1] = 71

const dict = map[string -> number]{
  "one" -> 1,
  "two" -> 2,
}

const dict2 = dict
dict2["one"] = 12
dict.set("y", 3)
dict1.intersect(dict2)
const x = dict.get("two")
dict.set("y", 3)
const z = dict.get("y")
let s = dict.pop("one")
let isExist = dict1.exists("one")

const dict1 = map[string -> number]{
  "one" -> 1,
  "two" -> 2,
}

const dict2 = map[string -> number]{
  "one" -> 4,
  "three" -> 3,
}

let newDict1 = dict2.intersect(dict1)
let newDict2 = dict1.union(dict2)


let nums: []number
nums = []number{1, 2, 3}
nums.append(10)
let nums2 = nums
nums.append(10)
nums.set(1, 1010)
nums2.slice(1, 3)
nums2.set(2, 100)
nums2[2] = 123
let x = nums2.len()
let y = nums2.cap()

let nums = [1, 2, 3]

let x = nums
  .each(fn(value) {
    return value % 2 == 0
  })
  .filter(fn(value) {
    return !value
  })

let x = [1, 2, 3]
// x = [1,] // if one element slice instansiation has to have a comma

interface Shape {
  vertices: int

  fn getSize() -> number
}

struct Circle : Shape {
  vertices: 0
  radius 

  fn getSize() -> number {
    return radius * radius * 3.14
  }
}

const myCircle = Circle{
  radius: 10
}
myCircle.getSize()
